blueprint:
  name: Home Assistant Auto-update on a schedule base
  author: Edward Firmo (https://github.com/edwardtfn)
  homeassistant:
    min_version: '2024.8.0'
  description: >
    # Home Assistant Auto-update

    Update Home Assistant automatically when a new update is available.

    v2024.9.30.0

    Attention:

    * Home Assistant may restart automatically as part of the update process.

    * **Use under your own risk!** Please see the discussions on Home Assistant community around the risks involved on auto-updating the system.

    For questions and suggestions, please use [this thread in Home Assistant Community portal](https://community.home-assistant.io/t/scheduled-auto-update-for-home-assistant/459281).
  domain: automation
  source_url: https://raw.githubusercontent.com/edwardtfn/HomeAssistant-Config/main/blueprints/automation/EdwardTFN/auto_update_scheduled.yaml
  input:
    when_section:
      name: When (Schedule, etc.)
      icon: mdi:calendar
      description: Select when the updates should happen and when it should be skipped.
      collapsed: false
      input:
        schedule_entity:
          name: Schedule entity
          description: 'You can create an [Schedule](https://www.home-assistant.io/integrations/schedule) under [Settings > Devices & Services > Helpers](https://my.home-assistant.io/redirect/config_flow_start/?domain=schedule).

            Note => The schedule windows will define when an update will start. It is possible that a backup, an update or a restart process finishes after the schedule window, but new updates won''t stars outside the schedule windows.'
          default: []
          selector:
            entity:
              multiple: false
              domain: schedule

        schedule_monthday:
          name: Earliest day in the month to update Home Assistant (optional)
          description: >
            Usually a new major version of Home Assistant is available on the begining of every month.
            Some people consider those releases as not stable enough and prefer to avoid those versions, not updating the system until the mid of the month (day 15).

            Note => If you select a day higher than 28 the updates won't run every month.
          default: 1
          selector:
            number:
              min: 1
              max: 31
              step: 1
              mode: slider

        update_out_of_schedule:
          name: Out of schedule entities (optional)
          description:
            You can select update entities which will be updated as soon an update is detected, even if outside the schedule windows.
          default: []
          selector:
            entity:
              multiple: true
              domain:
                - update

        pause_entities:
          name: Pause update entities (optional)
          description: 'You can select one or more entities to pause the updates. If any of the selected entities is "On" or "True" the system won''t be updated on the schedule time.

            You can use this to hold your updates when you have a party at home, or when you are on vacations and don''t want to be concerned about updates on Home Assistant.'
          default: []
          selector:
            entity:
              multiple: true
              domain:
                - input_boolean
                - binary_sensor
                - switch

    what_section:
      name: What (optional)
      icon: mdi:update
      description: Select what should be updated and what shouldn't be updated.
      collapsed: true
      input:
        core_os_update_mode:
          name: Update mode for Home Assistant core and OS updates
          description: >
            Please select the update mode for Home Assistant core and Home Assistan OS updates.

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: &update_mode-selector
            select:
              multiple: false
              options:
                - label: All
                  value: "all"
                - label: Patches only
                  value: "patches"
                - label: Don't update
                  value: "ignore"

        firmware_update_mode:
          name: Update mode for device's firmware
          description: >
            Please select the update mode for firmware in the devices connected to Home Assistant (when supported as an HA update).

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: *update_mode-selector

        general_update_mode:
          name: Update mode for general updates
          description: >
            Please select the update mode for everything that is not a device's firmware or a core component of Home Assistant.

            This includes add-ons, HACS componentes, custom cards, etc.

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: *update_mode-selector

        update_exclusions:
          name: Exclusions (optional)
          description: 'Select the items that should NOT be included on the automated updates.


            => Use this if you want to keep some add-on on an specific version and avoid auto-updates to it.'
          default: []
          selector:
            entity:
              multiple: true
              domain: update

    backup_section:
      name: Backup (optional)
      icon: mdi:backup-restore
      description: Select the back-up options
      collapsed: true
      input:
        backup_bool:
          name: Create a full backup before start the updates?
          default: true
          selector:
            boolean:
        backup_wait_time:
          name: Backup wait time
          description:
            Select how long the system should wait for the backup to be completed after it is triggered.

            Please make sure the schedule covers the waiting time, otherwise the update will never be triggered after a backup.
          default: 60
          selector:
            number:
              min: 0
              max: 3600
              step: 10
              mode: box
              unit_of_measurement: minutes
        max_backup_age:
          name: Maximum backup age (or zero, to disable) (optional)
          description:
            This requires the [Google Drive Backup](https://github.com/sabeechen/hassio-google-drive-backup)
            addon to be installed and configured to automatically backup, and provide
            a sensor with the backup states. The setting only checks for the age of
            the automatic backups from that addon, not the backups created internally
            by this blueprint.
          default:
            days: 0
            hours: 0
            minutes: 0
            seconds: 0
          selector:
            duration:
              enable_day: true

    actions_section:
      name: Actions (optional)
      icon: mdi:shoe-print
      description: Select actions to run at diferent moments on the update process
      collapsed: true
      input:
        actions_pre_update:
          name: Pre-update actions (optional)
          description: 'Actions to execute before the backup or any update starts.

            You can use this to send notifications, turn on/off devices or activate scenes before starting the updates.


            Note => Please be aware that all actions will run right before the update process, which can happens over-night. Take this in account when selecting your actions.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.'
          default: []
          selector:
            action: {}

        actions_pre_restart:
          name: Pre-restart actions (optional)
          description: 'Actions to execute before the automation requests a restart.

            You can use this to send notifications, turn on/off devices or stopping automations before restarting Home Assistant.


            Note => Please be aware that all actions will run right before the restart process, which can happens over-night. Take this in account when selecting your actions.

            Note => Note all the restarts will be controlled by this automation, like when a Core update is installed. These actions might not be executed in those cases.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.'
          default: []
          selector:
            action: {}

        actions_pos_update:
          name: Post-update actions (optional)
          description: >
            Actions to execute AFTER the update process finishes.

            You can use this to send notifications, turn on/off devices or activate scenes after applying  the updates.


            Note => Please be aware that all actions will run right after the update process, which can happens over-night.
            Take this in account when selecting your actions.

            Note => The variable "\{\{ updates_list \}\}" is available for your actions and contains the list of pending updates.

            **IMPORTANT** => Some updates will automatically restart Home Assistant, causing the automation to interrupt before finishing, preventing the pos-updates actions to be executed.
            If you have critical actions to run after an update, consider including also in another automation based on Home Assistant start.
          default: []
          selector:
            action: {}

    general_settings:
      name: General settings (optional)
      icon: mdi:cog
      description: Select additional settings to the update process
      collapsed: true
      input:
        restart_type:
          name: Force Home Assistant to restart if required by any update?
          description: This won't affect updates where a restart is automatic, but for updates requiring a manual restart (quite common on HACS) this blueprint can automatically force a restart by the end of the updates.
          default: "no-restart"
          selector:
            select:
              multiple: false
              options:
                - label: "Don't force a restart"
                  value: "no-restart"
                - label: "Restart Home Assistant core"
                  value: "core"
                - label: "Restart Home Assistant host"
                  value: "host"
        verbose_logging_bool:
          name: Log addon progress with verbosity to the logbook? (optional)
          default: false
          selector:
            boolean: {}

mode: single
max_exceeded: warning

trigger_variables:
  input_update_exclusions: !input update_exclusions
  input_update_out_of_schedule: !input update_out_of_schedule
  updates_available: >
    {% set updates_available_obj =
        states.update
        | default([])
        | selectattr("state", "eq", "on")
        | rejectattr("entity_id", "in", input_update_exclusions)
    %}
    {{
      updates_available_obj | map(attributes="entity_id") | list
      if (updates_available_obj | list | count | int(0) > 0)
      else []
    }}

trigger:
  - id: HA Schedule based
    platform: state
    entity_id: !input schedule_entity
  - id: HA Start
    platform: homeassistant
    event: start
  - id: New update
    platform: template
    value_template: >-
      {{
        states.update
        | default([])
        | selectattr("state", "eq", "on")
        | rejectattr("entity_id", "in", input_update_exclusions)
        | list | count | int(0) > 0
      }}
  - id: New day
    platform: time
    at: "00:00:01"
  - id: Automations reloaded
    platform: event
    event_type: automation_reloaded
  - id: Pause entities changed
    platform: state
    entity_id: !input pause_entities

condition:
  - condition: template
    value_template: >-
      {{
        states.update
        | default([])
        | selectattr("state", "eq", "on")
        | rejectattr("entity_id", "in", input_update_exclusions)
        | list | count | int(0) > 0
      }}

  - condition: or
    conditions:
      - condition: and
        conditions:
          - condition: template
            value_template: >
              {{ now().day >= ((input_schedule_monthday) | int(0)) }}
          - condition: state
            entity_id: !input schedule_entity
            state: "on"
      - condition: template
        value_template: >
          {% set ns = namespace(found=false) %}
          {% for item in input_update_out_of_schedule %}
            {% if item in updates_available %}
              {% set ns.found = true %}
              {% break %}
            {% endif %}
          {% endfor %}
          {{ ns.found }}

  - condition: or
    conditions:
      - "{{ input_pause_entities | default([]) | list | count | int(0) < 1 }}"
      - condition: state
        entity_id: !input pause_entities
        state: 'off'

variables:
  input_schedule_monthday: !input schedule_monthday
  input_pause_entities: !input pause_entities
  temp_input_update_exclusions: !input update_exclusions
  input_verbose_logging_bool: !input verbose_logging_bool
  input_backup_bool: !input backup_bool
  input_restart_type: !input restart_type

  temp_max_backup_age: !input max_backup_age
  input_max_backup_age_seconds: >
    {{
      timedelta(
        days=temp_max_backup_age.days,
        hours=temp_max_backup_age.hours,
        minutes=temp_max_backup_age.minutes,
        seconds=temp_max_backup_age.seconds
      ).total_seconds()
    }}

  input_core_os_update_mode: !input core_os_update_mode
  input_firmware_update_mode: !input firmware_update_mode
  input_general_update_mode: !input general_update_mode
  updates_list: []
  pending_updates_list: []

action:
  ########## Refresh update list ##########
  - &recalc_update_list
    variables:
      core_update_entity: >
            {% for u in integration_entities('hassio') | select('search', '^update[.]')
                    if (device_attr(u, 'identifiers') | first)[1] == 'core' %}
                {{ u }}
            {% endfor %}
      os_update_entity: >
            {% for u in integration_entities('hassio') | select('search', '^update[.]')
                    if (device_attr(u, 'identifiers') | first)[1] == 'OS' %}
                {{ u }}
            {% endfor %}
      supervisor_update_entity: >
            {% for u in integration_entities('hassio') | select('search', '^update[.]')
                    if (device_attr(u, 'identifiers') | first)[1] == 'supervisor' %}
                {{ u }}
            {% endfor %}
      firmware_update_entities: >
            {{ states.update
              | default([])
              | selectattr('attributes.device_class', 'defined')
              | selectattr('attributes.device_class', 'eq', 'firmware')
              | map(attribute='entity_id')
              | list
            }}
      general_update_entities: >
        {{ states.update
          | default([])
          | rejectattr('entity_id', 'in', core_update_entity)
          | rejectattr('entity_id', 'in', os_update_entity)
          | rejectattr('entity_id', 'in', supervisor_update_entity)
          | rejectattr('entity_id', 'in', firmware_update_entities)
          | map(attribute='entity_id')
          | list
        }}

      input_update_exclusions: >
            {% set exclusions = temp_input_update_exclusions | default([]) %}

            {% if input_core_os_update_mode == 'ignore' %}
              {% set exclusions = exclusions + [core_update_entity | default(""), os_update_entity | default("")] %}
            {% else %}
              {% set core_installed_version = states.update | default([]) | selectattr('entity_id', 'in', core_update_entity | default("")) | map(attribute='attributes.installed_version') | list | first | default('') %}
              {% set core_latest_version = states.update | default([]) | selectattr('entity_id', 'in', core_update_entity | default("")) | map(attribute='attributes.latest_version') | list | first | default('') %}
              {% set core_version_change = version(core_latest_version) - version(core_installed_version) %}
              {% set os_installed_version = states.update | default([]) | selectattr('entity_id', 'in', os_update_entity | default("")) | map(attribute='attributes.installed_version') | list | first | default('') %}
              {% set os_latest_version = states.update | default([]) | selectattr('entity_id', 'in', os_update_entity | default("")) | map(attribute='attributes.latest_version') | list | first | default('') %}
              {% set os_version_change = version(os_latest_version) - version(os_installed_version) %}

              {% if input_core_os_update_mode == 'patches' %}
                {% if core_version_change.major or core_version_change.minor or (not core_version_change.patch) %}
                  {% set exclusions = exclusions + [core_update_entity | default("")] %}
                {% endif %}
                {% if os_version_change.major or os_version_change.minor or (not os_version_change.patch) %}
                  {% set exclusions = exclusions + [os_update_entity | default("")] %}
                {% endif %}
              {% elif input_core_os_update_mode == 'major_and_minor' %}
                {% if (not core_version_change.major) and (not core_version_change.minor) %}
                  {% set exclusions = exclusions + [core_update_entity | default("")] %}
                {% endif %}
                {% if (not os_version_change.major) and (not os_version_change.minor) %}
                  {% set exclusions = exclusions + [os_update_entity | default("")] %}
                {% endif %}
              {% endif %}
            {% endif %}

            {% if input_firmware_update_mode == 'ignore' %}
              {% set exclusions = exclusions + [ firmware_update_entities ] %}
            {% else %}
              {% set ns = namespace(entities = []) %}
              {% for entity in expand(firmware_update_entities) | rejectattr('entity_id', 'in', exclusions) | selectattr('state', 'eq', 'on') %}
                {% set entity_version_change = version(entity.attributes.latest_version | default('')) - version(entity.attributes.installed_version | default('')) %}
                {% if input_firmware_update_mode == 'patches' %}
                  {% if entity_version_change.major or entity_version_change.minor or (not entity_version_change.patch) %}
                    {% set ns.entities = ns.entities + [ entity.entity_id ] %}
                  {% endif %}
                {% elif input_firmware_update_mode == 'major_and_minor' %}
                  {% if (not entity_version_change.major) and (not entity_version_change.minor) %}
                    {% set ns.entities = ns.entities + [ entity.entity_id ] %}
                  {% endif %}
                {% endif %}
              {% endfor %}
              {% set exclusions = exclusions + [ ns.entities ] %}
            {% endif %}

            {% if input_general_update_mode == 'ignore' %}
              {% set exclusions = exclusions + [ general_update_entities ] %}
            {% else %}
              {% set ns = namespace(entities = []) %}
              {% for entity in expand(general_update_entities) | rejectattr('entity_id', 'in', exclusions) | selectattr('state', 'eq', 'on') %}
                {% set entity_version_change = version(entity.attributes.latest_version | default('')) - version(entity.attributes.installed_version | default('')) %}
                {% if input_general_update_mode == 'patches' %}
                  {% if entity_version_change.major or entity_version_change.minor or (not entity_version_change.patch) %}
                    {% set ns.entities = ns.entities + [ entity.entity_id ] %}
                  {% endif %}
                {% elif input_general_update_mode == 'major_and_minor' %}
                  {% if (not entity_version_change.major) and (not entity_version_change.minor) %}
                    {% set ns.entities = ns.entities + [ entity.entity_id ] %}
                  {% endif %}
                {% endif %}
              {% endfor %}
              {% set exclusions = exclusions + [ ns.entities ] %}
            {% endif %}

            {{ exclusions }}

      pending_updates_list: >
            {{ states.update
              | default([])
              | selectattr('state','eq','on')
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list
            }}

  - alias: "Refresh update list - update entities"
    action: homeassistant.update_entity
    data: {}
    target:
      entity_id: "{{ states.update | map(attribute='entity_id') | list }}"
    continue_on_error: true
  - variables:
      updates_list: '{{ pending_updates_list }}'

  ########## Check for skipping core/OS ##########
  - alias: "Re-check conditions"
    continue_on_error: true
    if: >
      {{
        (
          states.update
          | selectattr('state','eq','on')
          | selectattr('entity_id', 'in', pending_updates_list)
          | rejectattr('entity_id', 'in', input_update_exclusions)
          | list
          | count
          | int(0)
        ) < 1
      }}
    then:
      - stop: Nothing to update
  ########## Starting ##########
  - &logbook-variables
    if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: Logbook - variables
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: >-
            Variables:
              input_backup_bool: {{ input_backup_bool }},
              input_restart_type: {{ input_restart_type }},
              input_verbose_logging_bool: {{ input_verbose_logging_bool }},
              input_max_backup_age_seconds: {{ input_max_backup_age_seconds }},
              input_schedule_monthday: {{ input_schedule_monthday }},
              input_update_exclusions: {{ input_update_exclusions }},
              input_core_os_update_mode: {{ input_core_os_update_mode }},
              input_firmware_update_mode: {{ input_firmware_update_mode }},
              input_general_update_mode: {{ input_general_update_mode }},
              core_update_entity: {{ core_update_entity }},
              os_update_entity: {{ os_update_entity }},
              supervisor_update_entity: {{ supervisor_update_entity }},
              firmware_update_entities: {{ firmware_update_entities }},
              general_update_entities: {{ general_update_entities }},
              updates_list: {{ updates_list }}
    continue_on_error: true

  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Logbook - A new update is available"
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          domain: update
          message: A new update is available for Home Assistant.
      - alias: "Logbook - List of updates"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          domain: update
          message: >
            List of updates:
            - {{ states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='name') | list | join('

            - ') }}
      - alias: "Logbook: Running pre-update actions"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: Running pre-update actions...
    continue_on_error: true

  - alias: "Run pre-update actions"
    continue_on_error: true
    choose:
      - conditions:
          - '{{ true }}'
        sequence: !input actions_pre_update
    default: []

  ########## Backup ##########
  - alias: Check existing backups uploaded
    continue_on_error: true
    if:
      - "{{ input_max_backup_age_seconds > 0 }}"
    then:
      - variables:
          last_backup_timestamp_list: >
            {{
              states.sensor
              | selectattr("attributes.last_backup", "defined")
              | map(attribute="attributes.last_backup")
              | list
            }}
          last_backup_timestamp: '{{ last_backup_timestamp_list | max if last_backup_timestamp_list | count > 0 else None }}'
      - alias: Check if backup state is defined
        if: '{{ last_backup_timestamp != None }}'
        then:
          - stop: "Backup State sensor not found"
      - alias: Check age of last uploaded backup
        if: >-
          {{ as_timestamp(now()) - as_timestamp(last_backup_timestamp) > input_max_backup_age_seconds }}
        then:
          - stop: "Last uploaded backup is too old"
  - alias: "Backup"
    continue_on_error: true
    if:
      - "{{ input_backup_bool }}"
    then:
      - if: "{{ input_verbose_logging_bool }}"
        then:
          - alias: "Logbook - Backing up"
            continue_on_error: true
            action: logbook.log
            data:
              name: Auto-update
              entity_id: '{{ this.entity_id }}'
              message: Backing up Home Assistant.
      - alias: "Call backup service"
        continue_on_error: true
        action: hassio.backup_full
        data:
          compressed: true
      - if: "{{ input_verbose_logging_bool }}"
        then:
          - alias: "Backup triggered"
            continue_on_error: true
            action: logbook.log
            data:
              name: Auto-update
              entity_id: '{{ this.entity_id }}'
              message: Backup triggered.
          - variables:
              backup_wait_time: !input backup_wait_time
              backup_wait_time_seconds: '{{ (backup_wait_time | int(60)) * 60 }}'
          - if: '{{ backup_wait_time_seconds > 0 }}'
            then:
              - alias: "Give selected wait time for the backup" # There's no sensor for when the backup finishes
                delay: '{{ backup_wait_time_seconds }}'
    else: []

  ########## Update add-ons (Standard) ##########
  - *recalc_update_list
  - *logbook-variables
  - alias: "Update - Standard"
    continue_on_error: true
    repeat:
      while:
        - "{{ input_general_update_mode in ['patches', 'major_and_minor', 'all'] }}"
        - condition: state
          entity_id: !input schedule_entity
          state: "on"
        - condition: template
          value_template: >
            {{ ( states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', core_update_entity)
              | rejectattr('entity_id', 'in', os_update_entity)
              | rejectattr('entity_id', 'in', firmware_update_entities)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0) ) > 0
            }}
      sequence:
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Standard - Logbook - Starting"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Starting sequence of standard updates..."
        - variables:
            pending_update_list: >
              {{ states.update
                | selectattr('state','eq','on')
                | selectattr('entity_id', 'in', pending_updates_list)
                | rejectattr('entity_id', 'in', core_update_entity)
                | rejectattr('entity_id', 'in', os_update_entity)
                | rejectattr('entity_id', 'in', firmware_update_entities)
                | rejectattr('entity_id', 'in', input_update_exclusions)
                | map(attribute='entity_id')
                | list
                }}
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Standard - Logbook - Updating"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Updating {{pending_update_list[0]}} of {{pending_update_list}} ..."
        - alias: "Update - Standard - Install"
          continue_on_error: true
          action: update.install
          data: {}
          target:
            entity_id: '{{ pending_update_list[0] }}'
        - alias: "Update - Standard - Wait"
          continue_on_error: true
          wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
          continue_on_timeout: true
          timeout: '3600'

  ########## Update core items ##########
  - *recalc_update_list
  - *logbook-variables
  - alias: "Update - Core"
    continue_on_error: true
    repeat:
      while:
        - "{{ input_core_os_update_mode in ['patches', 'major_and_minor', 'all'] }}"
        - condition: state
          entity_id: !input schedule_entity
          state: "on"
        - condition: template
          value_template: >
            {{ ( states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | selectattr('entity_id', 'in', core_update_entity)
              | rejectattr('entity_id', 'in', os_update_entity)
              | rejectattr('entity_id', 'in', firmware_update_entities)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0) ) > 0
            }}
      sequence:
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Core - Logbook - Starting"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Starting sequence of core items updates..."
        - variables:
            pending_update_list: >
              {{ states.update
                | selectattr('state','eq','on')
                | selectattr('entity_id', 'in', pending_updates_list)
                | selectattr('entity_id', 'in', core_update_entity)
                | rejectattr('entity_id', 'in', os_update_entity)
                | rejectattr('entity_id', 'in', firmware_update_entities)
                | rejectattr('entity_id', 'in', input_update_exclusions)
                | map(attribute='entity_id')
                | list
                }}
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Core - Logbook - Updating"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Updating {{pending_update_list[0]}} of {{pending_update_list}} ..."
        - alias: "Update - Core - Install"
          continue_on_error: true
          action: update.install
          data: {}
          target:
            entity_id: '{{ pending_update_list[0] }}'
        - alias: "Update - Core - Wait"
          continue_on_error: true
          wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
          continue_on_timeout: true
          timeout: '3600'

  ########## Update OS ##########
  - *recalc_update_list
  - *logbook-variables
  - alias: "Update - OS"
    continue_on_error: true
    repeat:
      while:
        - "{{ input_core_os_update_mode in ['patches', 'major_and_minor', 'all'] }}"
        - condition: state
          entity_id: !input schedule_entity
          state: "on"
        - condition: template
          value_template: >
            {{ ( states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', core_update_entity)
              | selectattr('entity_id', 'in', os_update_entity)
              | rejectattr('entity_id', 'in', firmware_update_entities)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0) ) > 0
            }}
      sequence:
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - OS - Logbook - Starting"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Starting sequence of OS update..."
        - variables:
            pending_update_list: >
              {{ states.update
                | selectattr('state','eq','on')
                | selectattr('entity_id', 'in', pending_updates_list)
                | rejectattr('entity_id', 'in', core_update_entity)
                | selectattr('entity_id', 'in', os_update_entity)
                | rejectattr('entity_id', 'in', firmware_update_entities)
                | rejectattr('entity_id', 'in', input_update_exclusions)
                | map(attribute='entity_id')
                | list
                }}
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - OS - Logbook - Updating"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Updating {{pending_update_list[0]}} of {{pending_update_list}} ..."
        - alias: "Update - OS - Install"
          continue_on_error: true
          action: update.install
          data: {}
          target:
            entity_id: '{{ pending_update_list[0] }}'
        - alias: "Update - OS - Wait"
          continue_on_error: true
          wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
          continue_on_timeout: true
          timeout: '3600'

  ########## Devices firmware ##########
  - *recalc_update_list
  - alias: "Update - Devices firmware"
    continue_on_error: true
    repeat:
      while:
        - "{{ input_firmware_update_mode in ['patches', 'major_and_minor', 'all'] }}"
        - condition: state
          entity_id: !input schedule_entity
          state: "on"
        - condition: template
          value_template: >
            {{ ( states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', core_update_entity)
              | rejectattr('entity_id', 'in', os_update_entity)
              | selectattr('entity_id', 'in', firmware_update_entities)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0) ) > 0
            }}
      sequence:
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Devices firmware - Logbook - Starting"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Starting sequence of Devices firmware update..."
        - variables:
            pending_update_list: >
              {{ states.update
                | selectattr('state','eq','on')
                | selectattr('entity_id', 'in', pending_updates_list)
                | rejectattr('entity_id', 'in', core_update_entity)
                | rejectattr('entity_id', 'in', os_update_entity)
                | selectattr('entity_id', 'in', firmware_update_entities)
                | map(attribute='entity_id')
                | list
                }}
        - if: "{{ input_verbose_logging_bool }}"
          then:
            - alias: "Update - Devices firmware - Logbook - Updating"
              continue_on_error: true
              action: logbook.log
              data:
                name: Auto-update
                entity_id: '{{ this.entity_id }}'
                message: "Updating {{pending_update_list[0]}} of {{pending_update_list}} ..."
        - alias: "Update - Devices firmware - Install"
          continue_on_error: true
          action: update.install
          data: {}
          target:
            entity_id: '{{ pending_update_list[0] }}'
        - alias: "Update - Devices firmware - Wait"
          continue_on_error: true
          wait_template: "{{ is_state(pending_update_list[0], 'off') }}"
          continue_on_timeout: true
          timeout: '3600'

    ########## Finishing ##########
  - *recalc_update_list
  - *logbook-variables
  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Logbook - Updating"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: Finishing update process.
      - alias: "Logbook - Remaining updates"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: >
            Remaining updates:
            - {{ states.update
              | selectattr('state','eq','on')
              | selectattr('entity_id', 'in', pending_updates_list)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='name') | list | join('

            - ') }}

  ########## Restart Home Assistant ##########
  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Restart - Logbook"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: >
            {{ states.update
              | selectattr('attributes.release_summary', 'defined')
              | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
              | map(attribute='entity_id')
              | list
              | count
              | int(0) }} item(s) pending a restart:
            - {{ states.update
              | selectattr('attributes.release_summary', 'defined')
              | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
              | map(attribute='entity_id')
              | list
              | join('
            - ') }}
  - alias: "Restart"
    continue_on_error: true
    if:
      - >-
        {{ input_restart_type != "no-restart" and (
          (
            states.update
            | selectattr('attributes.release_summary', 'defined')
            | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
            | map(attribute='entity_id')
            | list | count | int(0)
          ) > 0)
        }}
    then:
      - alias: "Restart - Check config"
        continue_on_error: true
        action: homeassistant.check_config
      - if:
          - "{{ states.persistent_notification.invalid_config.state | default('unavailable') == 'notifying' or states.persistent_notification.homeassistant_check_config.state | default('unavailable') == 'notifying' }}"
        then:
          - if: "{{ input_verbose_logging_bool }}"
            then:
              - alias: "Logbook: Running pre-restart actions"
                continue_on_error: true
                action: logbook.log
                data:
                  name: Auto-update
                  entity_id: '{{ this.entity_id }}'
                  message: Running pre-restart actions...
          - alias: "Run pre-restart actions"
            continue_on_error: true
            choose:
              - conditions:
                  - '{{ true }}'
                sequence: !input actions_pre_restart
            default: []
          - if: "{{ input_verbose_logging_bool }}"
            then:
              - alias: "Restart - Logbook - Skipping restart"
                continue_on_error: true
                action: logbook.log
                data:
                  name: Auto-update
                  entity_id: '{{ this.entity_id }}'
                  message: >
                    Skipping restart process due to notifications of invalid configurations:
                    states.persistent_notification.invalid_config.state = {{ states.persistent_notification.invalid_config.state | default('unavailable') }},
                    states.persistent_notification.homeassistant_check_config.state = {{ states.persistent_notification.homeassistant_check_config.state | default('unavailable') }}
        else:
          - alias: "Restart - Logbook - Restarting"
            continue_on_error: true
            action: logbook.log
            data:
              name: Auto-update
              entity_id: '{{ this.entity_id }}'
              message: 'Restarting Home Assistant {{ input_restart_type }}...'
          - alias: "Restart - Call reboot service"
            continue_on_error: true
            action: '{{ "hassio.host_reboot" if input_restart_type == "host" else "homeassistant.restart" }}'

    ########## Post-update actions ##########
  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Logbook - Post-actions"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: Running post-update actions...

  - alias: "Run post-update actions"
    continue_on_error: true
    choose:
      - conditions:
          - '{{ true }}'
        sequence: !input actions_pos_update
    default: []

    ########## Done! ##########
  - if: "{{ input_verbose_logging_bool }}"
    then:
      - alias: "Logbook - Done"
        continue_on_error: true
        action: logbook.log
        data:
          name: Auto-update
          entity_id: '{{ this.entity_id }}'
          message: Done!
