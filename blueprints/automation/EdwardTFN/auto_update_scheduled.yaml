####################################################################################################
#####                        Home Assistant Auto-update on Schedule                            #####
#####             Repository: https://github.com/edwardtfn/ha_auto_update_scheduled            #####
####################################################################################################
##### Purpose: YAML blueprint to automatically update Home Assistant and its components when   #####
#####          updates are available, following a schedule and with configurable options.      #####
####################################################################################################
##### Author: edwardtfn - https://github.com/edwardtfn - https://buymeacoffee.com/edwardfirmo  #####
####################################################################################################
##### NOTE:                                                                                    #####
##### - Home Assistant may restart automatically as part of the update process.                #####
##### - Use under your own risk! Please review Home Assistant community discussions about      #####
#####   the risks involved in auto-updating the system.                                        #####
##### - SECURITY WARNING:                                                                      #####
#####   - Ensure you have reliable backups before enabling automatic updates                   #####
#####   - Auto-updates in production environments may lead to system instability               #####
#####   - Updates may affect connected devices and integrations                                #####
##### - For discussions:                                                                       #####
#####     https://community.home-assistant.io/t/459281                                         #####
##### - For support, bug reports and new ideas:                                                #####
#####     https://github.com/edwardtfn/ha_auto_update_scheduled/issues                         #####
####################################################################################################
---
blueprint:
  name: Home Assistant Auto-update on a schedule base
  author: Edward Firmo (https://github.com/edwardtfn)
  homeassistant:
    min_version: 2025.8.0
  description: >
    # Home Assistant Auto-update

    Update Home Assistant automatically when a new update is available.

    ## v2025.12.1

    ### Changes:
    - Migrated from Telegram-specific notifications to generic `notify.send_message` action
    - Now supports any notify entity (Telegram, mobile app, etc.)
    - Automatic escaping of special characters for Telegram MarkdownV2 compatibility
    - Simplified configuration: just select a notify entity (no separate enable toggle needed)
    - Removed Telegram-specific settings (target ID, disable notification)

    ## Attention:

    - Home Assistant may restart automatically as part of the update process.

    - **Use under your own risk!** Please see the discussions on Home Assistant community around the risks involved on auto-updating the system.

    - Ensure you have reliable backups before enabling automatic updates.

    - Auto-updates in production environments may lead to system instability.

    - Updates may affect connected devices and integrations.

    ## For discussions:
      - [Home Assistant Community portal](https://community.home-assistant.io/t/459281)

    ## For support, bug reports and new ideas:
      - [GitHub Issues](https://github.com/edwardtfn/ha_auto_update_scheduled/issues)
  domain: automation
  source_url: https://raw.githubusercontent.com/edwardtfn/ha_auto_update_scheduled/main/auto_update_scheduled.yaml
  input:
    when_section:
      name: When (Schedule, etc.)
      icon: mdi:calendar
      description: Select when the updates should happen and when it should be skipped.
      collapsed: false
      input:
        schedule_entity:
          name: Schedule entity
          description: >
            You can create a [Schedule](https://www.home-assistant.io/integrations/schedule) under
            [Settings > Devices & Services > Helpers](https://my.home-assistant.io/redirect/config_flow_start/?domain=schedule).

            Note => The schedule windows will define when an update will start.
            It is possible that a backup, an update or a restart process finishes after the schedule window,
            but new updates won't stars outside the schedule windows.
          default: []
          selector:
            entity:
              multiple: false
              domain: schedule

        schedule_monthday_earliest:
          name: Earliest day in the month to run the update process
          description: >
            Usually a new major version of Home Assistant is available on the begining of every month.
            Some people consider those releases as not stable enough and prefer to avoid those versions,
            not updating the system until the mid of the month (day 15).

            Notes:
              - If you select a day higher than 28 the updates won't run every month.
              - Selecting `0` will disable the check.
          default: 0
          selector:
            number:
              min: 1
              max: 31
              step: 1
              mode: slider

        schedule_monthday_last:
          name: Latest day in the month to run the update process
          description: >
            Specify the latest day in month, on which this update can run.

            Note:
              - Selecting `0` or a date lower than the "Earliest Day" will disable the check.
          default: 0
          selector:
            number:
              min: 0
              max: 31
              step: 1
              mode: slider

        update_out_of_schedule:
          name: Out of schedule entities
          description: |
            `Optional`

            You can select update entities which will be updated as soon an update is detected,
            even if outside the schedule windows.

            Notes:
              - Pause entities will be respected and prevent the update of the out of schedule entities.
              - The out of schedule update can trigger a restart at an unexpected time outside the normal schedule.
                Please use it with caution.
          default: []
          selector:
            entity:
              multiple: true
              domain:
                - update

        pause_entities:
          name: Pause update entities
          description: |
            `Optional`

            You can select one or more entities to pause the updates.
            If any of the selected entities is "On" or "True" the system won't be updated on the schedule time.

            You can use this to hold your updates when you have a party at home,
            or when you are on vacations and don't want to be concerned about updates on Home Assistant.
          default: []
          selector:
            entity:
              multiple: true
              domain:
                - input_boolean
                - binary_sensor
                - switch

    what_section:
      name: What (optional)
      icon: mdi:update
      description: Select what should be updated and what shouldn't be updated.
      collapsed: true
      input:
        core_os_update_mode:
          name: Update mode for Home Assistant core and OS updates
          description: >
            Please select the update mode for Home Assistant core and Home Assistan OS updates.

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: &update_mode-selector
            select:
              multiple: false
              options:
                - label: All
                  value: "all"
                - label: Patches only
                  value: "patches"
                - label: Don't update
                  value: "ignore"

        firmware_update_mode:
          name: Update mode for device's firmware
          description: >
            Please select the update mode for firmware in the devices connected to Home Assistant (when supported as an HA update).

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: *update_mode-selector

        general_update_mode:
          name: Update mode for general updates
          description: >
            Please select the update mode for everything that is not a device's firmware or a core component of Home Assistant.

            This includes add-ons, HACS componentes, custom cards, etc.

            * All: All updates will be installed.

            * Patches only:
              ✅ From 2022.11.0 to 2022.11.3 will be updated (patches).
              ❌ From 2022.11.x to 2022.12.x will be ignored (minor update).
              ❌ From 2022.12.x to 2023.1.x will be ignored (major update).
            * Don't update: Ignore any update.

          default: "all"
          selector: *update_mode-selector

        update_inclusion_mode:
          name: Entity Inclusion Mode
          description: >-
            Please select the entity inclusion mode.
            * All:
              Just build the update entity list from all available update.* entities, which are in state 'on'.
            * Specified/Specified-Single:
              Build the update entity list from the specified entity list, filtering for entities in 'on' state.
              - Specified: Updates all matching entities
              - Specified-Single: Updates only the first matching entity
            * Searchfilter:
              This works as a wildcard filter.
              Examples:
                'update.zigbee2mqtt_'   => all update entities from zigbee2mqtt addon
                'update.esphome_'       => all update entities from esphome devices if their names start with 'esphome_'
            * Searchfilter-Single:
              Just like the searchfilter, but only the first entity. (Sorted alphabetically)
          default: "all"
          selector:
            select:
              multiple: false
              options:
                - label: All
                  value: "all"
                - label: Specified
                  value: "specified"
                - label: Specified-Single
                  value: "specified-single"
                - label: Searchfilter
                  value: "searchfilter"
                - label: Searchfilter-Single
                  value: "searchfilter-single"

        update_inclusion_entity_list:
          name: Entity Inclusion List
          description: >-
            => Important: This entity list will only be used when the Update Inclusion mode is set to "Specified" or "Specified-Single".
            Select the items which should be updated.
          default: []
          selector:
            entity:
              multiple: true
              domain: update

        update_inclusion_entity_searchfilter:
          name: Entity Inclusion Searchfilter
          description: >-
            => Important: This searchfilter will only be used when the Update Inclusion mode is set to "Searchstring".
            This defines the Searchfilter for finding the right update entities.
            This enables wildcard-like searching for a group of entities, aka "all zigbee entities" or "everything from Sonoff" etc.
          default: ""
          selector:
            text:
              multiline: false

        update_exclusions:
          name: Exclusions
          description: |
            `Optional`

            Select the items that should NOT be included on the automated updates.

            => Use this if you want to keep some add-on on an specific version and avoid auto-updates to it.
          default: []
          selector:
            entity:
              multiple: true
              domain: update

    backup_section:
      name: Backup (optional)
      icon: mdi:backup-restore
      description: Select the back-up options
      collapsed: true
      input:
        run_during_backup:
          name: Backup state sensor
          description: |
            `Optional`

            Is a sensor is selected, this automation will run only when that sensor reports backup state as `idle`.
            No update will be executed while the backup state sensor is in any other state or "unavailable".

            If no sensor is selected, this automation won't pause due to a backup in progress.
          default: []
          selector:
            entity:
              multiple: false
              filter:
                domain: sensor
                device_class: enum
                integration: backup

        backup_bool:
          name: Create a full backup before start the updates?
          default: true
          selector:
            boolean:

        last_backup_timestamp_entity:
          name: Last successful automatic backup sensor
          description: |
            `Optional`
          default: []
          selector:
            entity:
              multiple: false
              filter:
                domain: sensor
                device_class: timestamp
                integration: backup
        backup_timeout:
          name: Backup Timeout
          description: >-
            Specify how much time the automation waits for the backup process.
            We can't check wether the backup was successful.
            Per default we wait 1 hour to finish the backup.
          default: 60
          selector:
            number:
              mode: box
              min: 1
              max: 180
              unit_of_measurement: minutes

        max_backup_age:
          name: Maximum backup age (or zero, to disable)
          description: |
            `Optional`

            This requires the [Google Drive Backup](https://github.com/sabeechen/hassio-google-drive-backup)
            addon to be installed and configured to automatically backup, and provide
            a sensor with the backup states. The setting only checks for the age of
            the automatic backups from that addon, not the backups created internally
            by this blueprint.
          default:
            days: 0
            hours: 0
            minutes: 0
            seconds: 0
          selector:
            duration:
              enable_day: true

        backup_location:
          name: Backup Location
          description: |
            You can create a new backup location under [Settings > System > Storage](https://my.home-assistant.io/redirect/storage/).

            Specify where to store the backup for this autoupdate process.
          default: "/backup"
          selector:
            backup_location:

    actions_section:
      name: Actions (optional)
      icon: mdi:shoe-print
      description: Select actions to run at diferent moments on the update process
      collapsed: true
      input:
        actions_pre_update:
          name: Pre-update actions
          description: |
            `Optional`

            Actions to execute before the backup or any update starts.

            You can use this to send notifications, turn on/off devices or activate scenes before starting the updates.


            Note => Please be aware that all actions will run right before the update process,
            which can happens over-night. Take this in account when selecting your actions.

            Note => Some usefull variables available for your actions:
              - "`\{\{ updates_list \}\}`" - contains the list of updates when the automation started.
              - "`\{\{ updates_pending \}\}`" - contains the list of updates remaining to be updated.
          default: []
          selector:
            action: {}

        actions_pre_restart:
          name: Pre-restart actions
          description: |
            `Optional`

            Actions to execute before the automation requests a restart.

            You can use this to send notifications,
            turn on/off devices or stopping automations before restarting Home Assistant.


            Note => Please be aware that all actions will run right before the restart process,
            which can happens over-night. Take this in account when selecting your actions.

            Note => Note all the restarts will be controlled by this automation,
            like when a Core update is installed. These actions might not be executed in those cases.

            Note => Some usefull variables available for your actions:
              - "`\{\{ updates_list \}\}`" - contains the list of updates when the automation started.
              - "`\{\{ updates_pending \}\}`" - contains the list of updates remaining to be updated.
          default: []
          selector:
            action: {}

        actions_pos_update:
          name: Post-update actions
          description: |
            `Optional`

            Actions to execute AFTER the update process finishes.

            You can use this to send notifications, turn on/off devices or activate scenes after applying  the updates.


            Note => Please be aware that all actions will run right after the update process,
            which can happens over-night.
            Take this in account when selecting your actions.

            Note => Some usefull variables available for your actions:
              - "`\{\{ updates_list \}\}`" - contains the list of updates when the automation started.
              - "`\{\{ updates_pending \}\}`" - contains the list of updates remaining to be updated.

            **IMPORTANT** => Some updates will automatically restart Home Assistant,
            causing the automation to interrupt before finishing, preventing the pos-updates actions to be executed.
            If you have critical actions to run after an update,
            consider including also in another automation based on Home Assistant start.
          default: []
          selector:
            action: {}

    notification_section:
      name: Notifications (optional)
      icon: mdi:bell
      description: Here you can setup optional notifications. Select a notify entity to enable notifications.
      collapsed: true
      input:
        notification_entity:
          name: Notify entity
          description: >
            Select a notify entity to send messages to.

            This can be a Telegram notify entity, mobile app, or any other notify entity.

            Note: For Telegram entities, special characters will be automatically escaped.

            Leave empty to disable notifications.
          default: []
          selector:
            entity:
              multiple: false
              domain: notify

        notification_message_title:
          name: Notification title
          description: |
            `Optional`

            Please select a title to be used on each notification message.

            You can type a custom text.
          default:
            - friendly_name
          selector:
            select:
              custom_value: true
              multiple: false
              options:
                - label: Automation's friendly name
                  value: friendly_name
                - label: Automation's entity Id
                  value: entity_id
                - label: Blank (no title)
                  value: blank

        notification_select_notifications:
          name: Select what to notify
          description: |
            Select which steps should trigger notifications.
          default:
            - starting
            - list_of_updates
            - pre_update_actions
            - backup
            - update_progress
            - remaining_updates
            - restart
            - post_update_actions
            - done
          selector:
            select:
              multiple: true
              options:
                - label: (Re-)Starting message
                  value: starting
                - label: List of updates
                  value: list_of_updates
                - label: Pre-update actions
                  value: pre_update_actions
                - label: Backup
                  value: backup
                - label: Update progress
                  value: update_progress
                - label: Remaining updates
                  value: remaining_updates
                - label: Restart
                  value: restart
                - label: Post-update actions
                  value: post_update_actions
                - label: Done message
                  value: done

    general_settings:
      name: General settings (optional)
      icon: mdi:cog
      description: Select additional settings to the update process
      collapsed: true
      input:
        restart_type:
          name: Force Home Assistant to restart if required by any update?
          description: >
            This won't affect updates where a restart is automatic,
            but for updates requiring a manual restart (quite common on HACS)
            this blueprint can automatically force a restart by the end of the updates.
          default: "no-restart"
          selector:
            select:
              multiple: false
              options:
                - label: "Don't force a restart"
                  value: "no-restart"
                - label: "Restart Home Assistant core"
                  value: "core"
                - label: "Restart Home Assistant host"
                  value: "host"

        verbose_logging_bool:
          name: Log addon progress with verbosity to the logbook?
          description: |
            `Optional`

            When enabled, this automation will register each step on the logbook.

            This can be usefull for troubleshooting, but at normal conditions, it won't add much value.
          default: false
          selector:
            boolean: {}

        update_process_started_entity:
          name: '"Update Process Started" Toggle Entity'
          description: |
            `Optional`

            You can create a [Toggle Helper](https://www.home-assistant.io/integrations/input_boolean) under
            [Settings > Devices & Services > Helpers](https://my.home-assistant.io/redirect/config_flow_start/?domain=input_boolean).

            This entity will be used to determine if we still have to do a backup
            on automation start - so it is for inner workings of this automation.

            This saves you from getting multiple backups in the same update window.
          default: []
          selector:
            entity:
              multiple: false
              domain: input_boolean

        update_timeout:
          name: Update Timeout
          description: |
            Maximum time to wait for each update to complete.

            This protects the automation of waiting forever for an update that fails.

            Usually updates don't take that very long,
            so feel free to ajust this time to something that fits better your environment.

            The default is 1200 seconds (20 minutes).
            You can select any value between 10 seconds and 7200 seconds (2 hours).

            If an update times out:
            - The automation will log an error message
            - The automation will continue with the next update
            - The timed-out update may still complete in the background
          default: 1200
          selector:
            number:
              min: 10
              max: 7200
              step: 10
              unit_of_measurement: seconds
              mode: box

mode: single
max_exceeded: warning

trigger_variables:
  input_pause_entities: !input pause_entities
  input_update_exclusions: !input update_exclusions
  schedule_monthday_earliest: !input schedule_monthday_earliest
  schedule_monthday_last: !input schedule_monthday_last
  input_schedule_monthday_earliest: '{{ schedule_monthday_earliest | int(0) }}'
  input_schedule_monthday_last: '{{ schedule_monthday_last | int(0) }}'
  input_update_inclusion_entity_list: !input update_inclusion_entity_list
  input_update_inclusion_entity_searchfilter: !input update_inclusion_entity_searchfilter
  input_update_process_started_entity: !input update_process_started_entity
  update_out_of_schedule: !input update_out_of_schedule

trigger:
  - id: HA Schedule based
    platform: state
    entity_id: !input schedule_entity
  - id: HA Start
    platform: homeassistant
    event: start
  - id: New update
    platform: template
    value_template: >-
      {{
        states.update
        | default([])
        | selectattr("state", "eq", "on")
        | rejectattr("entity_id", "in", input_update_exclusions)
        | rejectattr("entity_id", "in", update_out_of_schedule)
        | list | count | int(0) > 0
      }}
  - id: New day
    platform: template
    value_template: >
      {{
        (now().day >= input_schedule_monthday_earliest or input_schedule_monthday_earliest == 0) and
        (
          now().day <= input_schedule_monthday_last or
          input_schedule_monthday_last == 0 or
          input_schedule_monthday_last < input_schedule_monthday_earliest
        )
      }}
  - id: Automations reloaded
    platform: event
    event_type: automation_reloaded
  - id: Pause entities changed
    platform: state
    entity_id: !input pause_entities
  - id: Out of schedule
    platform: state
    entity_id: !input update_out_of_schedule
    from: "off"
    to: "on"

condition:
  - condition: or
    conditions:
      - condition: trigger
        id: "Out of schedule"
      - condition: and
        conditions:
          - condition: or
            conditions:
              - condition: trigger
                id: "HA Start"
              - condition: trigger
                id: "Automations reloaded"
          - condition: template
            value_template: >-
              {{
                states.update
                | default([])
                | selectattr("state", "eq", "on")
                | selectattr("entity_id", "in", update_out_of_schedule)
                | rejectattr("entity_id", "in", input_update_exclusions)
                | list | count | int(0) > 0
              }}
      - condition: and
        conditions:
          - condition: state
            entity_id: !input schedule_entity
            state: 'on'
          - condition: template
            value_template: >-
              {{
                states.update
                | default([])
                | selectattr("state", "eq", "on")
                | rejectattr("entity_id", "in", input_update_exclusions)
                | list | count | int(0) > 0
              }}
      - condition: and
        conditions:
          - condition: trigger
            id: "HA Start"
          - '{{ input_update_process_started_entity | default([]) | count == 1 }}'
          - condition: state
            entity_id: !input update_process_started_entity
            state: "on"

  - condition: or
    conditions:
      - condition: trigger
        id: "Out of schedule"
      - condition: template
        value_template: >
          {{
            (now().day >= input_schedule_monthday_earliest or input_schedule_monthday_earliest == 0) and
            (now().day <= input_schedule_monthday_last or input_schedule_monthday_last == 0)
          }}

  - condition: or
    conditions:
      - "{{ input_pause_entities | default([]) | list | count | int(0) < 1 }}"
      - condition: state
        entity_id: !input pause_entities
        state: 'off'

variables:
  temp_input_update_exclusions: !input update_exclusions
  input_verbose_logging_bool: !input verbose_logging_bool
  input_core_os_update_mode: !input core_os_update_mode
  input_firmware_update_mode: !input firmware_update_mode
  input_general_update_mode: !input general_update_mode
  input_update_inclusion_mode: !input update_inclusion_mode
  input_notification_entity: !input notification_entity
  input_notification_select_notifications: !input notification_select_notifications
  input_notification_message_title: !input notification_message_title
  core_update_entity: >
    {% for u in integration_entities('hassio') | select('search', '^update[.]')
      if (device_attr(u, 'identifiers') | first)[1] == 'core' %}
        {{ u }}
    {% endfor %}
  os_update_entity: >
    {% for u in integration_entities('hassio') | select('search', '^update[.]')
      if (device_attr(u, 'identifiers') | first)[1] == 'OS' %}
        {{ u }}
    {% endfor %}
  supervisor_update_entity: >
    {% for u in integration_entities('hassio') | select('search', '^update[.]')
      if (device_attr(u, 'identifiers') | first)[1] == 'supervisor' %}
        {{ u }}
    {% endfor %}
  is_resume_after_restart: >
    {{
      input_update_process_started_entity | default([]) | count == 1 and
      is_state(input_update_process_started_entity | first, "on")
    }}
  is_out_of_schedule_mode: >
    {{
      trigger.id == "Out of schedule" or
      (
        (trigger.id == "HA Start" or trigger.id == "Automations reloaded") and
        (
          states.update
          | default([])
          | selectattr("state", "eq", "on")
          | selectattr("entity_id", "in", update_out_of_schedule)
          | rejectattr("entity_id", "in", input_update_exclusions)
          | list | count | int(0) > 0
        )
      )
    }}
  friendly_name: |
    {% set friendly_name_tmp = state_attr(this.entity_id, "friendly_name") | default("") %}
    {{
      friendly_name_tmp
      if friendly_name_tmp is string and friendly_name_tmp | length > 0
      else "Auto-update"
    }}
  is_telegram_notify: >
    {{ 
      input_notification_entity is string and 
      input_notification_entity | length > 0 and
      'telegram' in input_notification_entity.lower()
    }}
  notification_title: |
    {% if (input_notification_message_title == "friendly_name") %}
      {{ friendly_name }}
    {% elif (input_notification_message_title == "entity_id") %}
      {{ this.entity_id }}
    {% elif (input_notification_message_title != "blank" and
              input_notification_message_title is string and
              input_notification_message_title | length > 0) %}
      {{ input_notification_message_title }}
    {% else %}
      {{ "" }}
    {% endif %}
action:
  - alias: Refresh update entities
    action: homeassistant.update_entity
    data:
      entity_id: |
        {{
          states.update
          | default([])
          | rejectattr('entity_id', 'in', input_update_exclusions)
          | map(attribute='entity_id')
          | list
        }}
    continue_on_error: true

  - &recalc_update_list
    variables:
      firmware_update_entities: >
        {% if is_out_of_schedule_mode %}
          {# For out-of-schedule triggers, return empty list #}
          {# The update_out_of_schedule list will be added to combined_list directly #}
          []
        {% else %}
          {{
            states.update
            | default([])
            | selectattr("state", "eq", "on")
            | selectattr('attributes.device_class', 'defined')
            | selectattr('attributes.device_class', 'eq', 'firmware')
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
          }}
        {% endif %}
      general_update_entities: >
        {% if is_out_of_schedule_mode %}
          {# For out-of-schedule triggers, return empty list #}
          {# The update_out_of_schedule list will be added to combined_list directly #}
          []
        {% elif input_update_inclusion_mode == "all" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
          }}
        {% elif input_update_inclusion_mode == "specified" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'in', input_update_inclusion_entity_list)
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
          }}
        {% elif input_update_inclusion_mode == "specified-single" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'in', input_update_inclusion_entity_list)
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
            | first
          }}
        {% elif input_update_inclusion_mode == "searchstring" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'match', input_update_inclusion_entity_searchfilter)
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
          }}
        {% elif input_update_inclusion_mode == "searchfilter-single" %}
          {{
            states.update
            | default([])
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'match', input_update_inclusion_entity_searchfilter)
            | rejectattr('entity_id', 'in', core_update_entity)
            | rejectattr('entity_id', 'in', os_update_entity)
            | rejectattr('entity_id', 'in', supervisor_update_entity)
            | rejectattr('entity_id', 'in', firmware_update_entities)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
            | first
          }}
        {% endif %}
      input_update_exclusions: >
            {% set exclusions = temp_input_update_exclusions | default([]) %}

            {% if input_core_os_update_mode == 'ignore' %}
              {% set exclusions = exclusions + [core_update_entity | default(""), os_update_entity | default("")] %}
            {% else %}
              {% set core_installed_version = states.update
                                              | default([])
                                              | selectattr('entity_id', 'in', core_update_entity | default(""))
                                              | map(attribute='attributes.installed_version')
                                              | list
                                              | first
                                              | default('') %}
              {% set core_latest_version = states.update
                                            | default([])
                                            | selectattr('entity_id', 'in', core_update_entity | default(""))
                                            | map(attribute='attributes.latest_version')
                                            | list
                                            | first
                                            | default('') %}
              {% set core_version_change = version(core_latest_version) - version(core_installed_version) %}
              {% set os_installed_version = states.update
                                            | default([])
                                            | selectattr('entity_id', 'in', os_update_entity | default(""))
                                            | map(attribute='attributes.installed_version')
                                            | list
                                            | first
                                            | default('') %}
              {% set os_latest_version = states.update
                                          | default([])
                                          | selectattr('entity_id', 'in', os_update_entity | default(""))
                                          | map(attribute='attributes.latest_version')
                                          | list
                                          | first
                                          | default('') %}
              {% set os_version_change = version(os_latest_version) - version(os_installed_version) %}

              {% if input_core_os_update_mode == 'patches' %}
                {% if core_version_change.major or
                      core_version_change.minor or
                      (not core_version_change.patch) %}
                  {% set exclusions = exclusions + [core_update_entity | default("")] %}
                {% endif %}
                {% if os_version_change.major or
                      os_version_change.minor or
                      (not os_version_change.patch) %}
                  {% set exclusions = exclusions + [os_update_entity | default("")] %}
                {% endif %}
              {% elif input_core_os_update_mode == 'major_and_minor' %}
                {% if (not core_version_change.major) and (not core_version_change.minor) %}
                  {% set exclusions = exclusions + [core_update_entity | default("")] %}
                {% endif %}
                {% if (not os_version_change.major) and (not os_version_change.minor) %}
                  {% set exclusions = exclusions + [os_update_entity | default("")] %}
                {% endif %}
              {% endif %}
            {% endif %}

            {% if input_firmware_update_mode == 'ignore' %}
              {% set exclusions = exclusions + [ firmware_update_entities ] %}
            {% else %}
              {% set ns = namespace(entities = []) %}
              {% for entity in expand(firmware_update_entities)
                                | rejectattr('entity_id', 'in', exclusions)
                                | selectattr('state', 'eq', 'on') %}
                {% set entity_version_change = version(entity.attributes.latest_version | default(''))
                                                - version(entity.attributes.installed_version | default('')) %}
                {% if input_firmware_update_mode == 'patches' %}
                  {% if entity_version_change.major or
                        entity_version_change.minor or
                        (not entity_version_change.patch) %}
                    {% set ns.entities = ns.entities + [ entity.entity_id ] %}
                  {% endif %}
                {% elif input_firmware_update_mode == 'major_and_minor' %}
                  {% if (not entity_version_change.major) and (not entity_version_change.minor) %}
                    {% set ns.entities = ns.entities + [ entity.entity_id ] %}
                  {% endif %}
                {% endif %}
              {% endfor %}
              {% set exclusions = exclusions + [ ns.entities ] %}
            {% endif %}

            {% if input_general_update_mode == 'ignore' %}
              {% set exclusions = exclusions + [ general_update_entities ] %}
            {% else %}
              {% set ns = namespace(entities = []) %}
              {% for entity in expand(general_update_entities)
                                | rejectattr('entity_id', 'in', exclusions)
                                | selectattr('state', 'eq', 'on') %}
                {% set entity_version_change = version(entity.attributes.latest_version | default(''))
                                              - version(entity.attributes.installed_version | default('')) %}
                {% if input_general_update_mode == 'patches' %}
                  {% if entity_version_change.major or
                        entity_version_change.minor or
                        (not entity_version_change.patch) %}
                    {% set ns.entities = ns.entities + [ entity.entity_id ] %}
                  {% endif %}
                {% elif input_general_update_mode == 'major_and_minor' %}
                  {% if (not entity_version_change.major) and (not entity_version_change.minor) %}
                    {% set ns.entities = ns.entities + [ entity.entity_id ] %}
                  {% endif %}
                {% endif %}
              {% endfor %}
              {% set exclusions = exclusions + [ ns.entities ] %}
            {% endif %}

            {{ exclusions }}
      combined_list: >-
        {% set entities = namespace(list=[]) %}
        {%- if is_out_of_schedule_mode %}
          {# In out-of-schedule mode: ONLY include entities from update_out_of_schedule list #}
          {%- for entity in [update_out_of_schedule] %}
            {%- if entity is sequence and entity is not string %}
              {%- for item in entity %}
                {%- if item is string %}
                  {%- set entities.list = entities.list + [item] %}
                {%- endif %}
              {%- endfor %}
            {%- elif entity is string %}
              {%- set entities.list = entities.list + [entity] %}
            {%- endif %}
          {%- endfor %}
        {%- else %}
          {# Normal mode: Include all entity types #}
          {%- for entity in [firmware_update_entities, general_update_entities,
                            core_update_entity, os_update_entity, supervisor_update_entity] %}
            {%- if entity is sequence and entity is not string %}
              {%- for item in entity %}
                {%- if item is string %}
                  {%- set entities.list = entities.list + [item] %}
                {%- endif %}
              {%- endfor %}
            {%- elif entity is string %}
              {%- set entities.list = entities.list + [entity] %}
            {%- endif %}
          {%- endfor %}
        {%- endif %}
        {{ entities.list }}
      updates_pending: >-
        {% set updates = namespace(list=[]) %}
        {%- for entity in states.update %}
          {%- if (entity.state == "on" and
                  entity.entity_id in combined_list and
                  entity.entity_id not in input_update_exclusions) %}
            {%- set updates.list = updates.list + [entity.entity_id] %}
          {%- endif %}
        {%- endfor %}
        {{ updates.list }}
      pending_update_list: '{{ updates_pending }}'
      updates_pending_count: '{{ updates_pending | list | count | int(0) }}'

  - variables:
      update_list: '{{ updates_pending }}'
      updates_list: '{{ updates_pending }}'
      is_there_anything_to_update: '{{ updates_pending_count > 0 }}'

  - alias: Preparation  # Inform logbook and telegram which update automation is running
    sequence:
      - variables:
          log_message: '{{ friendly_name }} is {{ "re" if is_resume_after_restart else ""}}starting'
      - &logbook_update
        if: "{{ input_verbose_logging_bool }}"
        then:
          - alias: Logbook - Update
            action: logbook.log
            data:
              name: Auto-update
              entity_id: '{{ this.entity_id }}'
              message: '{{ log_message }}'
            continue_on_error: true
        continue_on_error: true
      - if: '{{ "starting" in input_notification_select_notifications }}'
        then:
          - &send_notification
            sequence:
              - variables:

                  notification_message: >-
                    {%- if is_telegram_notify -%}
                      {{ log_message
                        | replace('\\', '\\\\')
                        | replace('_', '\\_')
                        | replace('*', '\\*')
                        | replace('[', '\\[')
                        | replace(']', '\\]')
                        | replace('(', '\\(')
                        | replace(')', '\\)')
                        | replace('~', '\\~')
                        | replace('`', '\\`')
                        | replace('>', '\\>')
                        | replace('#', '\\#')
                        | replace('+', '\\+')
                        | replace('-', '\\-')
                        | replace('=', '\\=')
                        | replace('|', '\\|')
                        | replace('{', '\\{')
                        | replace('}', '\\}')
                        | replace('.', '\\.')
                        | replace('!', '\\!')
                      }}
                    {%- else -%}
                      {{ log_message }}
                    {%- endif -%}
              - if:
                  - condition: template
                    value_template: '{{ input_notification_entity | length > 0 }}'
                    alias: Check if notification entity is configured
                then:
                  - alias: Notify - Send message
                    action: notify.send_message
                    target:
                      entity_id: '{{ input_notification_entity }}'
                    data:
                      title: '{{ notification_title }}'
                      message: '{{ notification_message }}'
                    continue_on_error: true

  - alias: Report list of updates
    if:
      - '{{ is_there_anything_to_update }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - variables:
          log_message: >
            List of updates:

            - {{ states.update
                | selectattr('state', 'eq', 'on')
                | rejectattr('entity_id', 'in', input_update_exclusions)
                | map(attribute='name') | list | join("\n- ") }}
      - *logbook_update
      - if: '{{ "list_of_updates" in input_notification_select_notifications }}'
        then:
          - *send_notification
    else:
      - variables:
          log_message: "There's nothing to update"
      - *logbook_update
      - if: '{{ "list_of_updates" in input_notification_select_notifications }}'
        then:
          - *send_notification

  - alias: Set ON helper flag
    if:
      - '{{ input_update_process_started_entity | default([]) | count > 0 }}'
      - '{{ input_update_process_started_entity[0] | string | length > 0 }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - action: input_boolean.turn_on
        target:
          entity_id: !input update_process_started_entity
        continue_on_error: true

  - alias: Pre-update actions
    if:
      - '{{ is_there_anything_to_update }}'
      - '{{ not is_resume_after_restart }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - variables:
          input_actions_pre_update: !input actions_pre_update
      - condition: '{{ input_actions_pre_update is sequence }}'
      - *recalc_update_list
      - variables:
          log_message: 'Running pre-update actions...'
      - *logbook_update
      - if: '{{ "pre_update_actions" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - alias: "Run pre-update actions"
        continue_on_error: true
        sequence: !input actions_pre_update

      - variables:
          log_message: "Pre-update actions completed"
      - *logbook_update
      - if: '{{ "pre_update_actions" in input_notification_select_notifications }}'
        then:
          - *send_notification

  - alias: Backup
    if:
      - '{{ is_there_anything_to_update }}'
      - '{{ not is_resume_after_restart }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - *recalc_update_list
      - variables:
          input_backup_bool: !input backup_bool
          input_backup_timeout_minutes: !input backup_timeout
          input_backup_timeout: '{{ input_backup_timeout_minutes | int(60) }}'
          temp_max_backup_age: !input max_backup_age
          input_max_backup_age_seconds: >
            {{
              timedelta(
                days=temp_max_backup_age.days,
                hours=temp_max_backup_age.hours,
                minutes=temp_max_backup_age.minutes,
                seconds=temp_max_backup_age.seconds
              ).total_seconds()
            }}
      - alias: Check existing backups uploaded
        continue_on_error: true
        if:
          - '{{ not is_state("sensor.backup_state", "unknown") }}'
          - '{{ not is_state("sensor.backup_state", "unavailable") }}'
          - '{{ input_max_backup_age_seconds > 0 }}'
        then:
          - variables:
              last_backup_timestamp_list: >
                {{
                  states.sensor
                  | selectattr("attributes.last_backup", "defined")
                  | map(attribute="attributes.last_backup")
                  | list
                }}
              last_backup_timestamp: '{{ last_backup_timestamp_list | max if last_backup_timestamp_list | count > 0 else None }}'
          - alias: Check if backup state is defined
            if: '{{ last_backup_timestamp != None }}'
            then:
              - alias: Check age of last uploaded backup
                if: >-
                  {{ as_timestamp(now()) - as_timestamp(last_backup_timestamp) > input_max_backup_age_seconds }}
                then:
                  - variables:
                      log_message: "Last uploaded backup is too old"
                  - *logbook_update
                  - if: '{{ "backup" in input_notification_select_notifications }}'
                    then:
                      - *send_notification
                  - stop: "Last uploaded backup is too old"
            else:
              - variables:
                  log_message: "Backup State sensor not found"
              - *logbook_update
              - if: '{{ "backup" in input_notification_select_notifications }}'
                then:
                  - *send_notification
              - stop: "Backup State sensor not found"
      - alias: "Backup"
        continue_on_error: true
        if:
          - '{{ input_backup_bool }}'
          - condition: state
            entity_id: !input update_process_started_entity
            state: 'off'
        then:
          - action: input_boolean.turn_on
            target:
              entity_id: "{{ input_update_process_started_entity }}"
            continue_on_error: true
          - variables:
              log_message: "Backing up Home Assistant"
          - *logbook_update
          - if: '{{ "backup" in input_notification_select_notifications }}'
            then:
              - *send_notification

          - alias: "Call backup service"
            action: hassio.backup_full
            data:
              compressed: true
            continue_on_error: true

          - variables:
              log_message: >
                Backup triggered

                Waiting {{ input_backup_timeout | int(60) }} minutes
          - *logbook_update
          - if: '{{ "backup" in input_notification_select_notifications }}'
            then:
              - *send_notification

          - alias: "Wait for the backup"  # There's no sensor for when the backup finishes
            delay:
              minutes: "{{ input_backup_timeout | int(60) }}"

          - variables:
              log_message: >
                Backup Wait time finished.

                Continuing...
          - *logbook_update
          - if: '{{ "backup" in input_notification_select_notifications }}'
            then:
              - *send_notification

  - alias: Update generic
    if:
      - '{{ is_there_anything_to_update }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Update generic items"
      - *logbook_update
      - variables:
          log_message: 'Starting sequence of standard updates...'
      - *logbook_update
      - if: '{{ "update_progress" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - alias: "Update - Generic"
        continue_on_error: true
        repeat:
          while:
            - "{{ input_general_update_mode in ['patches', 'major_and_minor', 'all'] }}"
            - condition: or
              conditions:
                - condition: template
                  value_template: '{{ is_out_of_schedule_mode }}'
                - condition: state
                  entity_id: !input schedule_entity
                  state: "on"
            - condition: template
              value_template: >
                {{ ( states.update
                  | selectattr('state', 'eq', 'on')
                  | selectattr('entity_id', 'in', updates_pending)
                  | rejectattr('entity_id', 'in', core_update_entity)
                  | rejectattr('entity_id', 'in', os_update_entity)
                  | rejectattr('entity_id', 'in', firmware_update_entities)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='entity_id')
                  | list | count | int(0) ) > 0
                }}
          sequence:
            - variables:
                updates_pending: >
                  {{ states.update
                    | selectattr('state', 'eq', 'on')
                    | selectattr('entity_id', 'in', updates_pending)
                    | rejectattr('entity_id', 'in', core_update_entity)
                    | rejectattr('entity_id', 'in', os_update_entity)
                    | rejectattr('entity_id', 'in', firmware_update_entities)
                    | rejectattr('entity_id', 'in', input_update_exclusions)
                    | map(attribute='entity_id')
                    | list
                  }}
            - &get_next_update_entity
              variables:
                current_update_entity: '{{ updates_pending[0] }}'
                current_update_entity_friendly_name: |
                  {{ state_attr(current_update_entity, "friendly_name") | default(current_update_entity) }}

            - &log_updating
              alias: Log updating
              sequence:
                - variables:
                    log_message: 'Updating "{{ current_update_entity_friendly_name }}"...'
                - *logbook_update
                - if: '{{ "update_progress" in input_notification_select_notifications }}'
                  then:
                    - *send_notification

            - &update_install
              alias: "Update - Install"
              continue_on_error: true
              action: update.install
              data: {}
              target:
                entity_id: '{{ current_update_entity }}'

            - &update_wait
              alias: "Update - Wait"
              sequence:
                - alias: Wait
                  continue_on_error: true
                  wait_template: '{{ is_state(current_update_entity, "off") }}'
                  continue_on_timeout: true
                  timeout: !input update_timeout
                - if: '{{ wait.completed }}'
                  then:
                    - variables:
                        log_message: '"{{ current_update_entity_friendly_name }}" updated successfuly'
                    - *logbook_update
                    - if: '{{ "update_progress" in input_notification_select_notifications }}'
                      then:
                        - *send_notification
                  else:
                    - variables:
                        log_message: 'ERROR: "{{ current_update_entity_friendly_name }}" update timed out'
                    - *logbook_update
                    - if: '{{ "update_progress" in input_notification_select_notifications }}'
                      then:
                        - *send_notification

  - alias: Devices firmware
    if:
      - '{{ is_there_anything_to_update }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Device's firmware"
      - *logbook_update

      - variables:
          log_message: 'Starting sequence of Devices firmware update'
      - *logbook_update
      - if: '{{ "update_progress" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - alias: "Update - Devices firmware"
        continue_on_error: true
        repeat:
          while:
            - "{{ input_firmware_update_mode in ['patches', 'major_and_minor', 'all'] }}"
            - condition: or
              conditions:
                - condition: template
                  value_template: '{{ is_out_of_schedule_mode }}'
                - condition: state
                  entity_id: !input schedule_entity
                  state: "on"
            - condition: template
              value_template: >
                {{ ( states.update
                  | selectattr('state', 'eq', 'on')
                  | selectattr('entity_id', 'in', firmware_update_entities)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='entity_id')
                  | list | count | int(0) ) > 0
                }}
          sequence:
            - variables:
                updates_pending: >
                  {{ states.update
                    | selectattr('state', 'eq', 'on')
                    | selectattr('entity_id', 'in', firmware_update_entities)
                    | map(attribute='entity_id')
                    | list
                  }}

            - *get_next_update_entity
            - *log_updating
            - *update_install
            - *update_wait

  - alias: Update core
    if:
      - '{{ is_there_anything_to_update }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Update Core"
      - *logbook_update
      - variables:
          log_message: 'Starting sequence of core items updates...'
      - *logbook_update
      - if: '{{ "update_progress" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - alias: "Update - Core"
        continue_on_error: true
        repeat:
          while:
            - "{{ input_core_os_update_mode in ['patches', 'major_and_minor', 'all'] }}"
            - condition: or
              conditions:
                - condition: template
                  value_template: '{{ is_out_of_schedule_mode }}'
                - condition: state
                  entity_id: !input schedule_entity
                  state: "on"
            - condition: template
              value_template: >
                {{ ( states.update
                  | selectattr('state', 'eq', 'on')
                  | selectattr('entity_id', 'in', core_update_entity)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='entity_id')
                  | list | count | int(0) ) > 0
                }}
          sequence:

            - variables:
                updates_pending: >
                  {{ states.update
                    | selectattr('state', 'eq', 'on')
                    | selectattr('entity_id', 'in', core_update_entity)
                    | rejectattr('entity_id', 'in', input_update_exclusions)
                    | map(attribute='entity_id')
                    | list
                  }}

            - *get_next_update_entity
            - *log_updating
            - *update_install
            - *update_wait

  - alias: Update OS
    if:
      - '{{ is_there_anything_to_update }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Update OS"
      - *logbook_update
      - variables:
          log_message: "Starting sequence of OS update"
      - *logbook_update
      - if: '{{ "update_progress" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - alias: "Update - OS"
        continue_on_error: true
        repeat:
          while:
            - "{{ input_core_os_update_mode in ['patches', 'major_and_minor', 'all'] }}"
            - condition: or
              conditions:
                - condition: template
                  value_template: '{{ is_out_of_schedule_mode }}'
                - condition: state
                  entity_id: !input schedule_entity
                  state: "on"
            - condition: template
              value_template: >
                {{ ( states.update
                  | selectattr('state', 'eq', 'on')
                  | selectattr('entity_id', 'in', os_update_entity)
                  | rejectattr('entity_id', 'in', input_update_exclusions)
                  | map(attribute='entity_id')
                  | list | count | int(0) ) > 0
                }}
          sequence:

            - variables:
                updates_pending: >
                  {{ states.update
                    | selectattr('state', 'eq', 'on')
                    | selectattr('entity_id', 'in', os_update_entity)
                    | rejectattr('entity_id', 'in', input_update_exclusions)
                    | map(attribute='entity_id')
                    | list
                  }}

            - *get_next_update_entity
            - *log_updating
            - *update_install
            - *update_wait

  - alias: Update - Remaining  # Update all remaining items => this chaches up if some update item was left behind
    continue_on_error: true
    if:
      - '{{ is_there_anything_to_update }}'
      - condition: state
        entity_id: !input schedule_entity
        state: 'on'
    then:
      - *recalc_update_list
      - variables:
          log_message: "Updating all remaining items (if any)"
      - *logbook_update
      - variables:
          remaining_items: |
            {{ states.update
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'in', updates_pending)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
            }}
          remaining_items_count: '{{ remaining_items | count if remaining_items is sequence else 0 }}'

      - condition: '{{ remaining_items_count > 0 }}'

      - variables:
          log_message: |
            Remaining updates:
            - {{ remaining_items | join("\n- ") }}

      - *logbook_update
      - if: '{{ "update_progress" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - alias: "Update - Remaining - Install"
        continue_on_error: true
        service: update.install
        data: {}
        target:
          entity_id: >-
            {{ states.update
            | selectattr('state', 'eq', 'on')
            | selectattr('entity_id', 'in', updates_pending)
            | rejectattr('entity_id', 'in', input_update_exclusions)
            | map(attribute='entity_id')
            | list
            }}
      - alias: "Update - Remaining - Wait"
        continue_on_error: true
        wait_template: >-
          {{
            (
              states.update
              | selectattr('state', 'eq', 'on')
              | selectattr('entity_id', 'in', updates_pending)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | list
              | count
              | int(0)
            ) < 1
          }}
        continue_on_timeout: true
        timeout: !input update_timeout

  - alias: Finishing
    sequence:
      - *recalc_update_list
      - variables:
          log_message: "Finishing update process"
      - *logbook_update
      - if: '{{ "remaining_updates" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - variables:
          remaining_updates: |
            {{
              states.update
              | selectattr('state', 'eq', 'on')
              | selectattr('entity_id', 'in', updates_pending)
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='name')
              | list
            }}
          remaining_updates_count: '{{ remaining_updates | count | int(0) }}'
      - if: '{{ remaining_updates_count > 0 }}'
        then:
          - variables:
              log_message: |
                Remaining updates:
                - {{ remaining_updates | join("\n- ") }}
          - *logbook_update
          - if: '{{ "remaining_updates" in input_notification_select_notifications }}'
            then:
              - *send_notification
        else:
          - variables:
              log_message: "No remaining items to be updated"
          - *logbook_update

  - alias: Restart  # Restart Home Assistant
    sequence:
      - variables:
          input_restart_type: !input restart_type
      - condition: '{{ input_restart_type != "no-restart" }}'
      - alias: Wait pending operations  # Wait for any pending operations to complete
        continue_on_error: true
        wait_template: |
          {{
            (
              states.update
              | rejectattr('state', 'eq', 'off')
              | rejectattr('entity_id', 'in', input_update_exclusions)
              | map(attribute='entity_id')
              | list | count | int(0)
            ) < 1
          }}
        continue_on_timeout: true
        timeout:
          seconds: 30
      - &update_pending_restart_items
        variables:
          pending_restart_items: |
            {{ states.update
              | selectattr('attributes.release_summary', 'defined')
              | selectattr('attributes.release_summary', 'search', "<ha-alert alert-type='error'>")
              | map(attribute='name')
              | list
            }}
          pending_restart_items_count: '{{ pending_restart_items | count | int(0) }}'
      - if: '{{ pending_restart_items_count < 1 }}'
        then:
          - variables:
              log_message: 'Nothing requiring a restart'
          - *logbook_update
      - condition: '{{ pending_restart_items_count > 0 }}'
      - variables:
          log_message: >
            {{ pending_restart_items_count }} item{{ "s" if pending_restart_items_count > 1 }} pending a restart:

            - {{ pending_restart_items | join("\n- ") }}
      - *logbook_update
      - if: '{{ "restart" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - alias: "Restart"
        continue_on_error: true
        sequence:
          - condition: '{{ pending_restart_items_count > 0 }}'
          - alias: "Restart - Check config"
            continue_on_error: true
            action: homeassistant.check_config
          - variables:
              has_invalid_config: >
                {{
                  states.persistent_notification.invalid_config.state
                  | default('unavailable') == 'notifying'
                }}
              has_check_config_notification: >
                {{
                  states.persistent_notification.homeassistant_check_config.state
                  | default('unavailable') == 'notifying'
                }}
          - if: '{{ has_invalid_config or has_check_config_notification }}'
            then:
              - variables:
                  log_message: 'Running pre-restart actions...'
              - *logbook_update
              - if: '{{ "restart" in input_notification_select_notifications }}'
                then:
                  - *send_notification

              - alias: "Run pre-restart actions"
                continue_on_error: true
                sequence: !input actions_pre_restart
              - variables:
                  log_message: >
                    Skipping restart process due to notifications of invalid configurations:

                      - has_invalid_config = {{ has_invalid_config }}

                      - has_check_config_notification = {{ has_check_config_notification }}
              - *logbook_update
              - if: '{{ "restart" in input_notification_select_notifications }}'
                then:
                  - *send_notification
            else:
              - variables:
                  log_message: >
                    The system is set to restart automatically when an update requires it.

                    Restarting Home Assistant ({{ input_restart_type }})...
              - *logbook_update
              - if: '{{ "restart" in input_notification_select_notifications }}'
                then:
                  - *send_notification

              - alias: "Wait 15 seconds to deliver the telegram message."
                delay:
                  seconds: 15

              - alias: "Restart - Call reboot service"
                continue_on_error: true
                action: '{{ "hassio.host_reboot" if input_restart_type == "host" else "homeassistant.restart" }}'

  - alias: Post-update actions
    sequence:
      - variables:
          input_actions_pos_update: !input actions_pos_update
      - condition: '{{ input_actions_pos_update is sequence }}'
      - variables:
          log_message: "Running post-update actions"
      - *logbook_update
      - if: '{{ "post_update_actions" in input_notification_select_notifications }}'
        then:
          - *send_notification

      - alias: "Run post-update actions"
        continue_on_error: true
        sequence: !input actions_pos_update

  - alias: Set OFF helper flag
    if:
      - '{{ input_update_process_started_entity | default([]) | count > 0 }}'
      - '{{ input_update_process_started_entity[0] | string | length > 0 }}'
    then:
      - action: input_boolean.turn_off
        target:
          entity_id: !input update_process_started_entity
        continue_on_error: true

  - alias: Done  # All done!
    sequence:
      - variables:
          log_message: "Done!"
      - *logbook_update
      - if: '{{ "done" in input_notification_select_notifications }}'
        then:
          - *send_notification
...
